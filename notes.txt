-*- mode: markup; -*-

* Prose diff algorithm:

** Paragraph level diff

Compute the paragraph-level LCS of the document. (I.e. consider the
paragraphs as atomic elements.) This will find a backbone of unchanged
paragraphs in their original order as well as the places where
paragraphs were "deleted" and "added". However there are a number of
things that could actually have happened at the paragraph level which
would show up in different ways:

  # Edited. This will show up as a deletion and addition at
    the same place with a high similarity between the two.

  # Split. One deletion and multiple additions at the same
    place with a high similarity between the deletion and the
    concatenation of the additions.

  # Joined. Multiple deletions and one addition at the same
    place with a high similarity between the concatenation of the
    deletions and the addition.

  # Moved (and possibly edited). A deletion with no addition
    and elsewhere an addition with no deletion, with high similarity
    between the deletion and addition.

  # Deleted. A deletion with no similar addition elsewhere.

  # Added. An addition with no similar deletion elsewhere.

  # Sub-chunk moved. This will look like two edited paragraphs (as
    described above) except that after refining the diff at each
    edited location, we’ll get one deletion and one addition with high
    similarity to each other.

More complex situations include a paragraph split preceeded or
followed by other additions (or moves from elsewhere). Then there
would be a deletion and several additions in one place but only some
of the additions came from the split. Want to find the set of
consecutive additions that, when combined, yield the highest
similarity to the deleted paragraph. The remaining additions remain to
be accounted for as either actual additions or moves from elsewhere.
Similarly, a join in the neighborhood of other deletions should be
analyzed to find the set of consecutive deletions with the highest
similarity to the addition and the remaining deletions left to be
accounted for in some other way.

** Foo

  # Compute the paragraph-level diff. (I.e. a vector of :lcs, :delete,
    and :add elements)

  # For each diff location (a place where there are deletes and adds
    between elements of the LCS), refine it by diffing the
    concatenation of the deletes against the concatenation of the adds
    at the word or character level. If it is a simple edit (one
    delete; one add) this will detect it straight away. Similarly, a
    simple split or join will get diffed down to the right thing. A
    plain deletion or addition will have nothing to diff against so
    will be left alone. And more complex cases, such as editing a
    paragraph (a delete and an add) combined with adding or deleting
    neighboring paragraphs should get turned into more or less the
    right thing, namely a big chunk of, say, :add for an added
    paragraph followed by a set of :lcs, :delete, :add, bits showing
    the changes in the edited paragraph. However, there’s a danger
    that some of the LCS will come from the added paragraph before the
    edited one.

** Refinement

Given 







see if there is a high-similarity way
    to refine deletes and adds. For instance, if it’s actually a
    simple edited paragraph, i.e. there’s one delete and one add and
    their contents are highly similar, then replace the :delete and
    :add elements with the diff of their contents, so a bunch of new,
    smaller :lcs, :delete, and :add elements.








     
To determine what has happened:

  # Find exactly moved paragraphs and remove them from further
    consideration. (Another way to implement this is to simply find
    all the paragraphs that occur in both the old and new document.)

  # Build a matrix of the LCSs of each remaining paragraph against
    every other.




* Output

A set of paragraphs. Some paragraphs occur in both the original and
edited document and we record their position in each document.

Some paragraphs exist only in the original and some only in the
edited. There is a mapping between the original-only and edited-only
paragraphs the defines how they are releated.

 - Original to nothing: a deleted paragraph

 - nothing to Edited: a completely new paragraph

 - One original to one edited: an edited paragraph

 - One original to multiple edited: a split (and possibly edited) paragraph.

 - Multiple original to one edited: a joined (and possibly edited) parargraphs.

 - Two originals to two edited: chunk removed from original and moved
   to another paragraph. I.e. basically an edit of one paragraph to
   remove a chunk of text and then an edit of another paragraph to add
   a very similar chunk of text.



A set of paragraphs, each with a position (possibly Nil) in the
original document, a position (possibly (Nil) in the new document, and 


* Unmoved paragraphs

After we determine the simply equivalent paragraphs between original
and edited (identical paragraphs and symmetrically similar\note{Though
need to think about splits and joins}) we can find a sort of
abstracted LCS at the paragraph level. E.g. If we have a trivial case
of:

   A B C D E -> A' B' C' D' E'

where X' is equivalent to X, then the paragraph-level LCS is the whole
document. In general the unmoved paragraphs are the ones that are part
of the LCS.

We can then run through the rest of the paragraphs in edited and try
to figure out where they come from. 

Moved paragraphs will be ones that have versions in both original and
edited but which are not part of the LCS.

Extra paragraphs resulting from splits will have high one-way
similarity with the original version of a preceding or following
paragraph

Paragraphs resulting from joins will have high one-way similarity with multiple 

Totally new paragraphs will have low similarity to any paragraphs.


Truly deleted paragraphs
will be ones with no version 




Simple case: A single paragraph is in the “same” location if its
edited version follow an edited version of the paragraph the preceded
it in the original or precedes an edited version of the paragraph that
followed it in the original.

Slightly more complicated: if the preceding or following paragraphs in
edited are the result of a split, they should be considered descended
from the original paragraph. Thus if we have:

   AB C DE -> A' B' C' D' E'

Then paragraphs B and D are descendants of AB and DE, thus C' is in
the same position.

If the preceding or following paragraphs resulted from a join we have:

   A B C D E -> AB' C DE'

Since AB' descends from both A and B and DE' descends from both D and
E, C is similarly unmoved.

An unmoved paragraph may have 



* Deleted paragraphs

For paragraphs deleted from the original, find the paragraph
preceeding it in the original and determine what happened to it in the
editied. If it exists (perhaps in modified form) in the edited, put
the deleted paragraph, marked as deleted, after it. If it was also
deleted, find its preceeding paragraph, and so on, until a paragraph
that lives on in the edited verion is found. (Screw case #1: if the
preceeding paragraph was moved far away it would probably make more
sense to leave the deleted paragraphs where they were. Not sure how to
determine when a paragraph was moved. Screw case #2: if the preceeding
paragraph was joined with the paragraph following the deleted
paragraph(s). Probably should put the deleted paragraphs after the
joined paragraph.
